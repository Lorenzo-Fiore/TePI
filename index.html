<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tecnologie E Progettazioni Informatiche</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
    <nav>
      <ul>
        <li><a href="#arg1">Argomento 1</a></li>
        <li><a href="#arg2">Argomento 2</a></li>
        <li><a href="#arg3">Argomento 3</a></li>
      </ul>
    </nav>
  <main>
    <h1 id="titolo">Tecnologie e progettazione di sistemi informatici e di telecomunicazioni</h1>
    <div class="introduzione">
      <p id="text-int">
        Salve, mi chiamo Lorenzo Fiore e sono uno studente di quarta superiore presso l'istituto tecnico ISIS J.M. Keynes di Gazzada Schianno.
        Questo sito sarà una dispensa di quello che ho fatto nel periodo scolastico 2022-2023 riguardo alla materia informatica di nome TePI.
        Gli argomenti sono indicizzati <a href="#argomenti">qui sotto</a> e sono approfonditi nelle apposite sezioni della pagina a cui ci si
        può riferire attraverso il menu in alto.
      </p>
      <img src="img/me.jpg" alt="Errore">
    </div>
    <div class="args">
      <h2 id="argomenti">Argomenti</h2>
    <ol>
      <li>I 10 personaggi che hanno fatto l'informatica</li>
      <li>La comunicazione tra processi e thread</li>
      <li>La comunicazione con memoria condivisa</li>
    </ol>
    </div>
    <div class="arg1" id="arg1">
      <h2>I 10 personaggi che hanno fatto l'informatica</h2>
      <div class="text-1">
        <p>
          Durante la pre season dell'anno scolastico ho scoperto la vita di 10 personaggi che hanno 'costruito' l'informatica come la conosciamo
          oggi, studiando in particolare cosa hanno fatto per contribuire all'avanzamento di questa incredibile risorsa di cui sicuramente, come i
          primitivi trattavano il fuoco, ne stiamo sfruttando una piccola parte delle potenzialità.
          I personaggi affrontati, in ordine cronologico sono:
          <ol>
            <li>Ada Lovelace, la prima informatica della storia e colei che ha creato il primo programma informatico</li>
            <li>Alan Turing, il matematico che ha decifrato i codici di <a href="https://it.wikipedia.org/wiki/Enigma_(crittografia)" target="_blank" >Enigma</a> e colui che ha definito l'AI</li>
            <li>Steve Jobs, il fondatore di Apple e Pixar inoltre il creatore del <a href="https://it.wikipedia.org/wiki/Apple_I" target="_blank">primo PC</a> della storia</li>
            <li>Bill Gates, il fondatore di Microsoft nonchè creatore del MS-DOS e successivo Windows</li>
            <li>Tim Berners-Lee, l'ideatore del browser che utilizza il linguaggio HTML e i protocolli HTTP e URL</li>
            <li>Yang e Filo, i creatori del primo motore di ricerca, <a href="https://it.yahoo.com/" target="_blank">Yahoo</a></li>
            <li>Page e Bin, i creatori del più grande motore di ricerca, <a href="https://www.google.com/"target="_blank" >Google</a></li>
            <li><a href="https://it.wikipedia.org/wiki/Anonymous"target="_blank" >Anonymous</a>, l'ideologia che combatte per la difesa della libertà di pensiero e di espressione attraverso l'informatica</li>
            <li>Mark Zuckemberg, Il fondatore di Meta nonchè di Facebook</li>
            <li>Edward Snowden, l'informatico e attivista che combatte contro l'abuso di potere in ambito informatico del governo americano e britannico</li>
          </ol>
        </p>
      </div>
    </div>
    <div class="arg2" id="arg2">
      <h2>La comunicazione tra i thread e i processi</h2>
      <div class="proc-thread">
        <div id="proc">
          <p>
            <b>Processo:</b> un processo è un programma in memoria di massa che viene mandato in esecuzione nella cpu. Quando un programma viene mandato in esecuzione si dice istanza.
            L'idea di utilizzare i processi è nata per la multiprogrammaione, ovvero la possibilità di avere più cpu dette virtuali che eseguono processi diversi allo stesso momento.
            In realtà la multiprogrammazione non esiste, poichè nel caso avessimo un solo core, le cpu virtuali sono tutte la stessa cpu che è molto veloce a effettuare i <a href="#c-switch" style="color: red;">context-switch</a>.
            Ogni processo ha un proprio program counter (PC), ovvero un contatore alla linea successiva di codice che la cpu dovrà eseguire.
          </p>
          <img src="img/processo.PNG" alt="Errore">
        </div>
        <div id="thread">
          <p>
            <b>Thread:</b> un thread è un flusso di esecuzione all'interno di un processo che ha un proprio program counter (PC). All'interno di uno stesso processo si possono avere più thread che possono essere eseguiti da un solo processore
            oppure da più processori (multicore). I thread all'interno di uno stesso processo condividono l'area codice, la pcb, il controllo file e i dati. Inoltre i thread possono leggere, scrivere
            e cancellare lo stack degli altri, proprio per questo si dice che si possono vedere tra di loro.
          </p>
          <img src="img/thread.PNG" alt="Errore">
        </div>
      </div>
      <div class="c-switch" id="c-switch">
        <h2>Il Context-Switch tra thread e processi</h2>
        <div id="content">
          <p>
            <b>Context-Switch:</b> Il context-switch è una particolare operazione del sistema operativo che conserva lo stato del processo o thread in una tabella chiamata <a href="img/pcb.png" target="_blank" style="color: red;">PCB (process control block)</a>, in modo da poter essere ripreso in un altro momento. Questa attività permette a più processi di condividere la CPU, ed è anche una
            caratteristica essenziale per i sistemi operativi multitasking.
            Il context-switch tra thread è molto più veloce di quello tra processi poichè essendo i dati in condivisione, non bisogna passarli nella PCB.
            <br> Nella PCB dei processi vengono passati: Process Id, Process state, Process Priority, Accounting Information, Program counter, CPU register, PCB pointers.
          </p>
          <img src="img/c-switch.png" alt="Errore" id="a">
        </div>
      </div>
      <div class="thread-info">
        <h2>Le tipologie di thread</h2>
        <div class="fore-back">
          <p>
            Una delle classificazioni più importanti dei thread consiste nel differenziarli tra <FONT COLOR="red">Foreground</FONT> e <FONT COLOR="red">Background</FONT>.
          </p>
          <P id="fore">
            Un thread è foreground se una volta terminato il thread principale, esso continua a essere eseguito. In poche parole il processo prima di terminare deve aspettare che tutti i thread foreground terminino.
          </P>
          <p id="back">
            Un thread è background se una volta terminato il thread principale anch'esso termina. In poche parole appena il thread principale termina anche il processo termina.
          </p>
        </div>
      </div>
      <div class="KUI">
        <p>
          I thread hanno inoltre una classificazione per livelli, ovvero esistono thread a <FONT COLOR="red">Livello utente (molti a uno)</FONT>, thread a <FONT COLOR="red">Livello kernel (uno a uno)</FONT> 
          e thread <FONT COLOR="red">Ibridi</FONT>, ovvero di cui il programmatore ne sceglie se essere Utente o Kernel. Qui sotto una tabella che elenca le differenze tra le due tipologie.
        </p>
        <table class="wp-block-table" border="1">
          <tbody>
          <tr>
          <td><strong><span>BASE DI CONFRONTO</span></strong></td>
          <td><strong><span>FILETTATURA LIVELLO UTENTE</span></strong></td>
          <td><strong><span>KERNEL LEVEL THREAD</span></strong></td>
          </tr>
          <tr>
          <td><strong><span>Descrizione</span></strong></td>
          <td><span>Il supporto fornito a livello utente viene definito&nbsp;</span><strong><span>thread a livello utente</span></strong><span>&nbsp;. &nbsp;</span></td>
          <td><span>Il supporto fornito dal kernel è indicato come thread a livello di kernel. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Mappatura dei thread</span></strong></td>
          <td><span>Il thread a livello utente è anche chiamato thread di mapping molti-a-uno perché il sistema operativo mappa tutti i thread in un processo multithread a un singolo contesto di esecuzione.&nbsp;Il sistema operativo considera ogni processo multithread come una singola unità di esecuzione. &nbsp;</span></td>
          <td><span>I thread a livello di kernel supportano il mapping dei thread uno a uno.&nbsp;La mappatura richiede ogni thread utente con thread kernel.&nbsp;Il sistema operativo esegue questa mappatura. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Esempi</span></strong></td>
          <td><span>Esempi di librerie di thread utente includono: POSIX Pthreads, Mach C-thread e Solaris 2 UI-thread. &nbsp;</span></td>
          <td><span>Esempi di thread a livello di kernel includono: Windows NT, Windows 2000, Solaris 2, BeOS e Tru64 UNIX (precedentemente UNIX digitale) &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Tempo cambio contesto</span></strong></td>
          <td><span>Il tempo di cambio di contesto è inferiore. &nbsp;</span></td>
          <td><span>Il tempo di cambio di contesto è più. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Velocità</span></strong></td>
          <td><span>&nbsp;I thread a livello utente sono più veloci dei thread a livello di kernel. &nbsp;</span></td>
          <td><span>I thread a livello di kernel sono più lenti dei thread a livello utente. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Multithreading</span></strong></td>
          <td><span>L’applicazione multithread non può sfruttare il multiprocessing. &nbsp;</span></td>
          <td><span>Le routine del kernel stesse possono essere multithread. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Supporto hardware</span></strong></td>
          <td><span>Il cambio di contesto richiede il supporto hardware &nbsp;</span></td>
          <td><span>È necessario il supporto hardware. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Implementazione</span></strong></td>
          <td><span>L’implementazione dei thread utente è semplice. &nbsp;</span></td>
          <td><span>L’implementazione del thread del kernel è complicata. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Sistema operativo</span></strong></td>
          <td><span>Il livello utente può essere eseguito su qualsiasi sistema operativo. &nbsp;</span></td>
          <td><span>I thread a livello di kernel sono specifici del sistema operativo. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Codice dell’applicazione</span></strong></td>
          <td><span>Il codice per creare e distruggere il thread, il passaggio dei messaggi, il trasferimento dei dati e la pianificazione dei thread è incluso nella libreria dei thread. &nbsp;</span></td>
          <td><span>Il codice di gestione dei thread non è incluso nel codice dell’applicazione.&nbsp;È l’unica API per il thread del kernel.&nbsp;Il sistema operativo Windows utilizza questa funzione. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Chiamate di sistema</span></strong></td>
          <td><span>I thread a livello utente non richiamano il kernel per la decisione di pianificazione. &nbsp;</span></td>
          <td><span>I thread sono costruiti e controllati da chiamate di sistema.&nbsp;Il sistema conosce lo stato di ogni thread. &nbsp;</span></td>
          </tr>
          <tr>
          <td><strong><span>Spazio operativo</span></strong></td>
          <td><span>Il thread a livello utente utilizza lo spazio per la pianificazione del thread.&nbsp;I thread sono trasparenti per il sistema operativo. &nbsp;</span></td>
          <td><span>Il kernel esegue la pianificazione su base thread.&nbsp;Il supporto del kernel e la creazione del thread di gestione avviene solo nello spazio del kernel. &nbsp;</span></td>
          </tr>
          </tbody>
        </table>
      </div>
      <div class="stati-thread">
        <h2>Gli stati di un thread</h2>
        <div id="content2">
          <ul>
            <li>Ready: in attesa di essere assegnato alla cpu</li>
            <li>Running: in esecuzione dalla cpu</li>
            <li>Waiting: in attesa di un evento</li>
            <li>Sleeping: sospeso per un quantitativo di tempo</li>
            <li>Blocking: in attesa di completare un I/O</li>
            <li>Dead: istruzioni terminate</li>
          </ul>
          <img src="img/stati-thread.png" alt="Errore">
        </div>
      </div>
      <div class="operazioni-thread">
        <h2>Le operazioni eseguibili sui thread</h2>
        <p>
          Il programmatore ha a disposizione diversi strumenti per controllare i thread, qua sotto sono elencate con il nome dell'azione che compiono e la corrispondente funzione in Java e C#.
        </p>
        <ol>
          <li>thread_create "<FONT COLOR="red">start()</FONT>": un thread chiede di crearne uno nuovo</li>
          <li>thread_exit "<FONT COLOR="red">abort()</FONT>": un thread termina se stesso</li>
          <li>
            thread_join "<FONT COLOR="red">join()</FONT>": un thread sincronizza la sua fine con quella di un altro, <br>
            appena l'altro finisce manda una notify ad esso
          </li>
          <li>thread_yeld "<FONT COLOR="red">yeld()</FONT>": rilascia la cpu ad un altro thread in coda</li>
          <li>thread_sleep "<FONT COLOR="red">sleep()</FONT>": ferma il thread per un quantitativo di tempo, spesso in millisecondi</li>
        </ol>
      </div>
    </div>
    <div class="arg3" id="arg3">
      <h2>La comunicazione con la memoria condivisa</h2>
      <div class="indice">
        <p>
          Qui sotto un indice degli argomenti di cui si tratta nello studio della comunicazione con la memoria condivisa da parte dei processi:
        </p>
        <ul>
          <li><a href="#1">La comunicazione tra processi e thread</a></li>
          <li><a href="#2">I semafori</a></li>
          <li><a href="#3">Mutex (approfondimento)</a></li>
          <li><a href="#4">La comunicazione con scambio di messaggi</a></li>
          <li><a href="#5">I problemi della gestione dei processi</a></li>
        </ul>
      </div>
      <div class="com-proc-thread" id="1">
        <h2>La comunicazione tra processi e thread che hanno memoria condivisa</h2>
        <div class="intro-critica">
          <p id="intro">
            Quando più processi hanno una risorsa condivisa su cui possono agire contemporaneamente, lo stato finale di essa viene deciso dall'ordine in cui i processi vi accedono.
            In poche parole si rischia di non avere il risultato desiderato perchè i processi non hanno sguito l'ordine che ci si aspettava.
            Facciamo un esempio.
          </p>
          <div class="esempio1">
            <p>
              Supponiamo di avere due processi, P0 e P1. <br>P0 produce dati del cliente per n clienti e li inserisce nel buffer mentre P1 legge i dati dal buffer e li stampa a schermo.
              Come si può vedere nell'immagine sotto, dato che i due processi non sono sincronizzati tra di loro, può accadere che P1 legga i dati prima di essere stati effettivamente
              cambiati nel buffer da P0, dando in questo caso un saldo nel contocorrente n.130 che non è quello reale di quella persona ma è quello del conto 125, infatti dovrebbe essere 2000
              ma è rimasto 3500.
            </p>
            <img src="img/mem-cond/esempio1.png" alt="Errore">
          </div>
        </div>
        <div class="critica">
          <h2>Corsa critica, sezione critica e mutua esclusione</h2>
          <p>
            Si dice <FONT COLOR="red">corsa critica</FONT> quella situazione dove due o più processi accedono a dati condivisi e il risultato dell'elaborazione dipende dall'ordine di esecuzione dei processi. <br>
          </p>
          <p>
            Si dice <FONT COLOR="red">sezione critica</FONT> o regione critica la parte di codice dove può avvenire la corsa critica, ovvero la parte di codice che accede alla memoria condivisa.
          </p>
          <p>
            Per risolvere questo problema si ha bisogno della <FONT COLOR="red">mutua esclusione</FONT> dei processi che consiste nel far entrare un processo alla volta nella propria sezione critica. Per esempio, se P0 è nella sua sezione critica, 
            allora P1 non potrà entrare nella propria.
          </p>
          <p>Per avere la mutua esclusione si necessita di 6 condizioni:</p>
          <ol>
            <li>un solo Processo o Thread accede alla sezione critica;</li>
            <li>nessun processo può bloccarsi in sezione critica;</li>
            <li>non ci sono deadlock e starvation;</li>
            <li>non viene fatta nessuna assunzione sulla velocità dei processi;</li>
            <li>nessun processo fuori dalla sezione critica può impedire a un altro di entrare;</li>
            <li>l'accesso alla sezione critica è consentito in un tempo definito.</li>
          </ol>
        </div>
        <div class="sol-bool">
          <h2>Soluzione con variabile booleana</h2>
          <div class="sol-bool-content">
            <p>
              Un modo per risolvere il problema della mutua esclusione è l'utilizzo di una variabile booleana che decide quale dei due processi può entrare nella sezione critica.
              Consideriamo una variabile booleana StatoBuffer e se questa vale <FONT COLOR="green">TRUE</FONT> significa che il Buffer è pieno, altrimenti se vale <FONT COLOR="red">FALSE</FONT> il Buffer è vuoto. Ovviamente la variabile
              StatoBuffer in questo caso deve essere inizializzata a false, poichè il buffer è inizialmente vuoto.
            </p>
            <img src="img/mem-cond/booleana.png" alt="Errore">
          </div>
          <div class="busy-waiting">
            <h3>Busy Waiting</h3>
            <p>
              Il problema di questa soluzione sta nei due while interni che provocano quella che si chiama 'attesa attiva' o <FONT COLOR="red">Busy-Waiting</FONT>. In sostanza, se la condizione non è verificata, 
              il processore continua a lavorare testandone ciclicamente il verificarsi. Questo provoca spreco dirisorse e cioè di tempo di CPU ed è da evitare. Vediamo come risolvere questo problema attraverso i semafori.
            </p>
          </div>
        </div>
      </div>
      <div class="semafori" id="2">
        <h2>Il semaforo</h2>
        <div class="definizione">
          <p id="def">
            Un <FONT COLOR="red">semaforo</FONT> è un tipo di dato astratto che permette la gestione organizzata dell'accesso di 2 o più processi/thread a una sezione critica.
          </p>
            <div class="comp-semaforo">
              <div class="testo-sem">
                <p>Si compone di due parti:</p>
                <ul>
                  <li>Una variable intera <FONT COLOR="red">contatore</FONT></li>
                  <li>Una <FONT COLOR="red">coda</FONT> di processi associata</li>
                </ul>
              </div>
              <img src="img/mem-cond/semaforo.png" alt="Errore">
            </div>
            <div class="tipologia-sem">
              <p>
                Un semaforo può essere di 2 tipologie: <FONT COLOR="red">counter</FONT> e <FONT COLOR="red">mutex</FONT>.
              </p>
              <ul>
                <li>counter se può assumere anche valori > 1 e quindi permettere di eseguire più thread alla volta</li>
                <li>mutex se assume valori da 0 a 1 e nel caso un thread fa una lock (wait) con cont == 0, esso viene bloccato fino a che cont non ritorni a 1</li>
              </ul>
            </div>
              <div class="ws">
                <p>
                  Il thread/processo può eseguire tre operazioni su un semaforo: create, wait, signal o post. Queste funzioni vengono dette <FONT COLOR="red">atomiche</FONT> poichè
                  non possono essere interrotte mentre eseguite. Qui a fianco gli pseudocodici di wait e signal.
                </p>
                <img src="img/mem-cond/wait-signal.png" alt="Errore">
              </div>
              <div class="wait">
                <p>
                  Come si nota dai codici, quando un thread fa una <FONT COLOR="red">wait</FONT> su un semaforo, il suo contatore viene decrementato e nel caso:
                </p>
                <ul>
                  <li>S.Cont >= 0 il thread può essere eseguito non essendo nessun altro thread in coda</li>
                  <li>S.Cont < 0 il semaforo ha una coda, un thread è gia in esecuzione e quindi questo thread viene accodato e bloccato con numero di coda uguale a valore assoluto di S.Cont, per esempio -2 sarà il secondo ad essere eseguito finito quello in esecuzione</li>
                </ul>
              </div>
              <div class="signal">
                <p>
                  Sempre guardando il codice, si può notare che la <FONT COLOR="red">signal</FONT> corrisponde ad un aumento del contatore del semaforo e nel caso:
                </p>
                <ul>
                  <li>S.Cont > 0 non bisogna eseguire nessun altro thread essendo la coda del semaforo vuota</li>
                  <li>S.Cont <= 0 avendo il semaforo almeno un processo in coda, esso viene estratto ed eseguito</li>
                </ul>
              </div>
              <h2>Esempio</h2>
              <div class="es-ws">
                <p>
                  Per fare un esempio, affidiamoci alle immagini in basso a destra. Quella in alto è il processo principale, quelle sotto sono un processo 0 e un processo 1 che devono accedere a una sezione critica. <br>
                  Il Count viene inizializzato a 1, perché se lo inizializzassimo a 0 i due processi entrerebbero subito in stato di Wait e nessuno li riattiverebbe.
                </p>
                <div class="content-es1">
                  <ol>
                    <li>P1 arriva prima alla fase di Wait ed esegue la Wait.</li>
                    <li>Il Count del Semaforo Mutex viene decrementato. Da 1 diventa 0.</li>
                    <li>Non è minore di zero, di conseguenza esce dalla funzione senza entrare nell'if ed entra nella sua sezione critica.</li>
                    <li>Nel mentre P0 arriva ad eseguire la sua Wait sullo stesso semaforo.</li>
                    <li>Il Count di Mutex viene decrementato ancora. Da 0 passa a -1.</li>
                    <li>È minore di zero, quindi entra nell'if e il processo P0 viene messo in coda.</li>
                    <li>P1 esce dalla zona critica ed entra nella Signal.</li>
                    <li>Il Count di Mutex viene incrementato. Da -1 diventa 0.</li>
                    <li>Il Count è uguale a zero quindi riattiva P0 .</li>
                    <li>P0 entra nella sua zona critica, la esegue, esce da questa, esegue la Signal e il Count torna a 1 ed è pronto per altre esecuzioni.</li>
                  </ol>
                  <img src="img/mem-cond/es-ws.png" alt="Errore">
                </div>
                <p>
                  L'esempio proposto permette la mutua esclusione tra due o più processi/thread, poichè il contatore non è stato inizializzato a 0.
                  Nel caso questo fosse accaduto, il semaforo non avrebbe funzionato tuttavia qualche volta è utile lo stesso farlo, bisogna solo cambiare
                  l'implementazione delle funzioni atomiche nei codici dei processi. Infatti se si inizializza il Count a 0, lo si fa per sincronizzare i processi,
                  non per escluderli mutualmente. Per sincronizzare si intende per esempio far partire un processo quando l'altro è finito.
                  Vediamo un esempio:
                </p>
                <div class="content-es2">
                  <ol>
                    <li>P0 arriva per primo all'istruzione di Wait.</li>
                    <li>l Count del semaforo S viene decrementato. Da 0 passa a -1.</li>
                    <li>Valendo -1 il processo P0 viene messo nella coda del Semaforo S.</li>
                    <li>P1 esce dalla procedura “RilevaEvento” perché sta arrivando un treno ed esegue la Signal su Semaforo S.</li>
                    <li>Il Count del semaforo S viene incrementato. Da -1 diventa 0.</li>
                    <li>Essendo uguale a zero, entra nell'if, estrae P0 dalla coda e lo manda in esecuzione. Quindi P0 dà il permesso di partire al treno.</li>
                  </ol>
                  <img src="img/mem-cond/es-ws2.png" alt="Errore">
                </div>
              </div>
          </div>
          <div class="mutex" id="3">
            <h2>Il semaforo binario MUTEX (approfondimento)</h2>
            <p id="def-mutex">
              Un semaforo binario <FONT COLOR="red">mutex</FONT> si utilizza quando si vuole gestire l'accesso a una sezione critica senza utilizzare una coda e applicando la mutua esclusione, ovvero far si che quando un thread
              si trova nella sezione critica, gli altri siano completamente bloccati aspettando di essere risvegliati dallo scheduler quando il cont del mutex ritorna a 1. 
              Ovviamente non avendo una coda ordinata dei processi in attesa, tutti questi vengono risvegliati e il primo ad eseguire la lock (wait) sarà quello eseguito, mentre gli altri ritornano in attesa.
              La differenza sostanziale tra un semaforo e un mutex sta nel fatto che il primo è fatto per segnalare se un thread è già in esecuzione,
              mentre il secondo è fatto proprio per bloccare i thread non in esecuzione. Nel semaforo infatti un thread può fare wait e signal quando vuole e sta al programmatore gestirli con un criterio,
              nel mutex invece è impossibile che un thread faccia una lock o unlock mentre un altro thread è in esecuzione.
            </p>
            <div class="creazione-mutex">
              <p>
                La prima operazione che un thread può fare su un mutex è la <FONT COLOR="red">create</FONT>. <br>
                È importante però sapere che a differenza di un semaforo (che è una variabile), un mutex è una struttura di nome pthread_mutex_t che contiene:
              </p>
              <ul>
                <li>Nome del mutex</li>
                <li>Proprietario</li>
                <li>Contatore</li>
                <li>Struttura associata al mutex</li>
                <li>La coda dei processi sospesi in attesa che mutex sia libero.</li>
              </ul>
              <p>
                Essendo una struttura/oggetto per inizializzare un mutex ci sono due modi: <FONT COLOR="red">statico</FONT> e <FONT COLOR="red">dinamico</FONT> 
              </p>
              <div class="statico">
                <h3>Statico</h3>
                <div class="spiegazione-statico">
                    <p>
                      Per il tipo di dato pthread_mutex_t, è definita la macro
                      di inizializzazione <FONT COLOR="red">PTHREAD_MUTEX_INITIALIZER</FONT> 
                    </p>
                    <img src="img/mem-cond/statico.PNG" alt="Errore">
                </div>
              </div>
              <div class="dinamico">
                <h3>Dinamico</h3>
                <div class="spiegazione-dinamico">
                  <ol>
                    <li>
                      pthread_mutex_t *mutex
                      <ul>
                        <li>puntatore al mutex da inizializzare</li>
                      </ul>
                    </li>
                    <li>
                      pthread_mutexattr_t *mattr
                      <ul>
                        <li>attributi del mutex da inizializzare</li>
                        <li>se NULL usa valori default</li>
                      </ul>
                    </li>
                    <li>
                      Valore di ritorno sempre 0
                    </li>
                  </ol>
                  <img src="img/mem-cond/dinamico.PNG" alt="Errore">
                </div>
              </div>
            </div>
            <div class="lock-unlock">
              <p>
                Oltre alla create, le operazioni che un processo può eseguire su un mutex sono la <FONT COLOR="red">lock</FONT> e l'<FONT COLOR="red">unlock</FONT>, le equivalenti della wait e signal sui semafori.
                <br>È importante sapere che un thread può fare una unlock solo se prima ha fatto una lock, impedendo ad altri thread di 'rompere' il mutex, cosa che può accadere con i semafori se il programmatore non fa attenzione.<br>
              </p>
              <div class="lock">
                <p>Sono tre le cose importanti da sapere riguardo alla <FONT COLOR="red">lock</FONT>:</p>
                <ul>
                  <li>Ogni thread, prima di accedere ai dati condivisi, deve effettuare la lock su una stessa variabile mutex.</li>
                  <li>Blocca l'accesso da parte di altri thread.</li>
                  <li>
                    Se più thread eseguono l'operazione di lock su una
                    stessa variabile mutex, solo uno dei thread termina
                    la lock e prosegue l'esecuzione, gli altri rimangono
                    bloccati nella lock. In tal modo, il processo che
                    continua l'esecuzione può accedere ai dati (protetti
                    mediante la mutex).
                  </li>
                </ul>
                <p>
                  Oltre alla lock esiste anche la <FONT COLOR="red">trylock</FONT> che è come la lock() ma se si accorge che la mutex è già in
                  possesso di un altro thread (e quindi si rimarrebbe
                  bloccati) restituisce immediatamente il controllo al
                  chiamante con risultato EBUSY. La sua proprietà non bloccante la rende perfetta per evitare i <FONT COLOR="red">deadblock</FONT> di cui si parla più avanti.
                </p>
                <div class="lock-trylock">
                  <div class="spieg-lock">
                    <h3>Lock</h3>
                    <div class="content-lock">
                      <ol>
                        <li>
                          pthread_mutex_t *mutex
                          <ul>
                            <li>puntatore al mutex da bloccare</li>
                          </ul>
                        </li>
                        <li>
                          Valore di ritorno
                          <ul>
                            <li>0 in caso di successo</li>
                            <li>diverso da 0 altrimenti</li>
                          </ul>
                        </li>
                      </ol>
                      <img src="img/mem-cond/lock.PNG" alt="Errore">
                    </div>
                  </div>
                  <div class="spieg-trylock">
                    <h3>Trylock</h3>
                    <div class="content-trylock">
                      <ol>
                        <li>
                          pthread_mutex_t *mutex
                          <ul>
                            <li>puntatore al mutex da bloccare</li>
                          </ul>
                        </li>
                        <li>
                          Valore di ritorno
                          <ul>
                            <li>0 in caso di successo e si ottenga la proprietà della mutex</li>
                            <li>EBUSY se il mutex è occupato</li>
                          </ul>
                        </li>
                      </ol>
                      <img src="img/mem-cond/trylock.png" alt="Errore">
                    </div>
                  </div>
                </div>  
              </div>
              <div class="unlock">
                <p>Sono 2 invece le cose da sapere riguardo alla <FONT COLOR="red">unlock</FONT>:</p>
                <ul>
                  <li>Libera la variabile mutex.</li>
                  <li>Può essere eseguita solo dal thread che ha precedentemente eseguito la lock</li>
                </ul>
                <div class="spieg-unlock">
                  <h3>Unlock</h3>
                  <div class="content-unlock">
                    <ol>
                      <li>
                        pthread_mutex_t *mutex
                        <ul>
                          <li>puntatore al mutex da sbloccare</li>
                        </ul>
                      </li>
                      <li>
                        Valore di ritorno
                        <ul>
                          <li>0 in caso di successo</li>
                        </ul>
                      </li>
                    </ol>
                    <img src="img/mem-cond/unlock.png" alt="Errore">
                  </div>
                </div>
              </div>
              <div class="destroy">
                <p>L'ultima operazione che un thread può eseguire sul mutex è la <FONT COLOR="red">destroy</FONT>, che come dice il nome serve per deallocare lo spazio in RAM dedicato al mutex.</p>
                <div class="content-destroy">
                  <ol>
                    <li>Elimina il mutex</li>
                    <li>
                      pthread_mutex_t *mutex
                      <ul>
                        <li>puntatore al mutex da distrugge</li>
                      </ul>
                    </li>
                    <li>
                      Valore di ritorno
                      <ul>
                        <li>0 in caso di successo</li>
                        <li>EBUSY se il mutex è occupato</li>
                      </ul>
                    </li>
                  </ol>
                  <img src="img/mem-cond/destroy.png" alt="Errore">
                </div>
              </div>
            </div>
          </div>
          <div class="esempi-imp">
            <h2>Utilizzo specifico dei semafori</h2>
            <p id="intro-imp">
              I casi più comuni per cui serve l'utilizzo dei semafori sono 2, il caso del <FONT COLOR="red">Produttore - Consumatore</FONT> e il caso del <FONT COLOR="red">Lettore - Scrittore</FONT>. <br> Qui sotto sono scritti i codici per risolvere questi problemi.
            </p>
            <div class="prod-cons">
              <h3>Produttore - Consumatore</h3>
              <div class="intro-prod-cons">
                <p id="intro1">
                  Mettiamo caso di voler gestire due processi P0 e P1. Il primo serve per produrre dati (in questo caso stringhe) e il secondo li deve leggere.
                  Partiamo dal presupposto di avere un solo buffer dati, utilizzato per depositare momentaneamente i dati da scambiare e inoltre prepariamo 2 semafori, uno che ci segnala se del testo
                  è stato depositato nel buffer (Depositato) e l'altro che ci segnala se del testo è stato prelevato dal buffer (Prelevato).
                </p>
              </div>
              <div class="content1">
                <ol>
                  <li>Il Consumatore arriva per primo alla fase di Wait.</li>
                  <li>Il count di Depositato viene decrementato. Da 0 passa a -1.</li>
                  <li>È minore di zero, quindi entra nell'if e viene messo nella coda del semaforo Depositato.</li>
                  <li>Nel mentre il Produttore, dopo aver prodotto il Dato, arriva alla fase di Wait su Prelevato.</li>
                  <li>Il count di Prelevato viene decrementato. Da 1 passa a 0.</li>
                  <li>Non è minore di zero quindi non entra nell'if e prosegue. Scrive il Dato nel buffer.</li>
                  <li>Il Produttore esegue poi la Signal sul semaforo Depositato.</li>
                  <li>Il count da -1 passa a 0. Essendo uguale a zero estrae il Consumatore dalla coda e lo riattiva.</li>
                  <li>Il Consumatore copia il Dato dal buffer ed esegue la Signal su Prelevato.</li>
                  <li>Prevelevato viene incrementato. Da 0 torna ad 1.</li>
                </ol>
                <img src="img/mem-cond/es-prod-cons/prod-con-main.png" alt="Errore">
              </div>
              <p>I due Processi sono in mutua esclusione e abbiamo quindi risolto il problema delProduttore – Consumatore.</p>
            </div>
            <div class="let-scrit">
              <h3>Lettore - Scrittore</h3>
              <div class="intro-let-scrit">
                <p id="intro2">
                 Supponiamo in questo caso di avere un'area di memoria condivisa tra più processi, lettori e scrittori.
                 <br> Ci sono 3 importanti regole da rispettare:
                </p>
                <ul>
                  <li>La scrittura dei dati può essere effettuata da un solo processo scrittore alla volta.</li>
                  <li>La lettura dei dati può essere fatta da più processi lettori a condizione che non ci siano scrittori che stanno scrivendo.</li>
                  <li>Quando uno scrittore accede ai dati nessun altro può accedervi, né lettore né scrittore.</li>
                </ul>
                <p>È inoltre importante per capire il seguente codice conoscere questo:</p>
                <ul>
                  <li>La variabile Lettori conta quanti sono i lettori. Se non c'è nessun lettore, si può scrivere.</li>
                  <li>Il Semaforo Scrivi serve a garantire l'accesso in mutua esclusione alle operazioni di scrittura.</li>
                  <li>Il Semaforo Mutex assicura la mutua esclusione per la scrittura della variabile Lettori.</li>
                </ul>
              </div>
              <div class="content2">
                <ol>
                  <li>Un processo scrittore arriva alla sua fase di Wait</li>
                  <li>Il Count di Scrivi viene decrementato. Da 1 passa a 0.</li>
                  <li>Non entra nell'if e passa alla scrittura.</li>
                  <li>Nel mentre un processo lettore arriva alla fase di Wait per il semaforo Mutex.</li>
                  <li>Il Count di Mutex viene decrementato. Da 1 diventa 0.</li>
                  <li>Non entra nell'if ed incrementa la variabile Lettori, che da 0 passa ad 1, indicando così che è presente un processoLettore.</li>
                  <li>Entra nell'if ed esegue la Wait su scrivi, così da verificarese c'è un processo scrittore che sta Scrivendo. Essendocene uno non può leggere.</li>
                  <li>Il Count di Scrivi da 0 passa a -1.</li>
                  <li>È minore di zero quindi entra nell'if e viene messo in coda.</li>
                  <li>Intanto arriva un altro scrittore che esegue la Wait su Scrivi.</li>
                  <li>Il Count di Scrivi da -1 arriva a -2.</li>
                  <li>Entra nell'if e anche questo scrittore viene messo in coda.</li>
                  <li>Il primo scrittore termina la sua scrittura ed esegue la Signal su Scrivi, che da -2 torna a -1.</li>
                  <li>Entra nell'if e riattiva il lettore che era in coda.</li>
                  <li>Il lettore esegue la Signal su Mutex, che ritorna a 1; Non entra nell'if e prosegue.</li>
                  <li>Legge i Dati e decrementa la variabile Lettori che torna a 0; quindi entra nell'if ed esegue la Signal su Scrivi, 
                      così facendo indica che ora non ci sono più Lettori e che se ci fosse uno scrittore potrebbe scrivere.</li>
                  <li>l Count di Scrivi torna a 0; Entra nell'if e riattiva il secondo Scrittore che riprende ad eseguire.</li>
                </ol>
                <img src="img/mem-cond/es-prod-cons/let-scrit-main.png" alt="Errore">
              </div>
            </div>
          </div>
        </div>
        <div class="messaggi" id="4">
          <h2>La comunicazione con scambio di messaggi</h2>
          <div class="intro-com">
            <p>
              Quando bisogna far comunicare tra di loro dei <FONT COLOR="red">sistemi distribuiti</FONT> si utilizza la comunicazione attraverso lo scambio di messaggi.
              I sistemi distribuiti sono quei sistemi che contemporaneamente devono eseguire uno stesso progetto ma sono situati in posti diversi quindi necessitano di una comunicazione. 
              I diversi processi sono eseguiti su computer differenti collegati da canali di comunicazione. <br>
            </p>
            <p style="margin-top: 50px;">Per farlo si utilizzano 2 primitive:</p>
            <div class="send-receive">
              <ul>
                <li><FONT COLOR="red">Send</FONT> (Destinatario, Messaggio)</li>
                <li><FONT COLOR="red">Receive</FONT> (Sorgente, Messaggio)</li>
              </ul>
              <img src="img/mem-cond/send-receive.PNG" alt="Errore">
            </div>
            <p style="margin-top: 50px;">Le send e le receive possono sia essere bloccanti che non bloccanti, ovvero possono rispettivamente: </p>
            <div class="send">
              <p style="line-height: 40px;"><b>Send bloccante: </b>quando il processo che esegue la Send si blocca finchè il messaggio è stato ricevuto e ne ha avuto conferma tramite una ricevuta di ritorno (ad Esempio, Ack).</p>
              <p><b>Send non bloccante: </b>quando il processo dopo aver spedito il messaggio prosegue nella sua normale esecuzione.</p>
            </div>
            <div class="receive" style="margin-top: 50px;">
              <p style="line-height: 40px;"><b>Receive bloccante: </b>quando ad esempio il processo P si ferma in attesa di ricevere il messaggio inviato da Q. In questo caso P esegue una Receive del tipo: Receive (Q, Msg);</p>
              <p><b>Receive non bloccante: </b>quando il processo che la esegue non si ferma inattesa del messaggio e ci si può trovare in due condizioni diverse:</p>
              <ul>
                <li>Il messaggio era già stato inviato prima che il processo facesse la Receive, quindi appena il processo fa la receive ottiene il messaggio.</li>
                <li>Il messaggio non era stato mandato, ma questo processo ha fatto la Receive, non attende, prosegue e perde il messaggio.</li>
              </ul>
            </div>
          </div>
          <div class="messaggio">
            <p>I dati che si trasmettono attaverso la comunicazione con send e receive si chiamano <FONT COLOR="red">messaggi</FONT> e sono composti da 2 parti:</p>
            <div class="comp-mes">
              <ul>
                <li>Una serie di informazioni di controllo.</li>
                <li>Il messaggio vero e proprio.</li>
              </ul>
              <img src="img/mem-cond/messaggio.PNG" alt="Errore">
            </div>
          </div>
          <div class="mailbox">
            <h2>La mailbox (indirizzamento non diretto)</h2>
            <p>
              Abbiamo visto prima un tipo di indirizzamento diretto, dove la sorgente invia direttamente al destinatario il messaggio. <br> Esiste anche l'indirizzamento indiretto dove si utilizza una Mailbox.
            </p>
            <p style="margin-top: 50px;">In questo caso le primitive sono:</p>
            <div class="mail-content">
              <ul>
                <li>Send (Mailbox, Messaggio)</li>
                <li>Receive (Mailbox, Messaggio)</li>
              </ul>
              <img src="img/mem-cond/mailbox.PNG" alt="Errore">
            </div>
          </div>
          <div class="es-mess">
            <h2>Esempi di comunicazione</h2>
            <p>
                Qui sotto sono riportati due esempi di comunicazione, la prima diretta con send e receive bloccanti e la seconda attraverso l'utilizzo di una mailbox, 
                con send non bloccante e receive bloccante.
            </p>
              <div class="es-mes-1">
                <h3>Esempio 1</h3>
              <p>
                Il produttore decide di produrre un Dato e lo manda al consumatore e si accerta che lo riceva. 
                Il consumatore esegue la Receive ma non va avanti finchè non è sicuro di ricevere il messaggio.
              </p>
              <div class="es-mes-1-content">
                <ol>
                  <li>Parte per primo il Consumatore.</li>
                  <li>Esegue la Receive.</li>
                  <li>Il Produttore non ha ancora prodotto nulla, quindi il Consumatore si blocca in attesa.</li>
                  <li>Il Produttore esegue la Send.</li>
                  <li>Il Consumatore riceve il Dato e invia la ricevuta al Produttore.</li>
                  <li>Il produttore rimane nella Send fino a quando non riceve la ricevuta.</li>
                </ol>
                <img src="img/mem-cond/messaggi-1.PNG" alt="Errore">
              </div>
            </div>
            <div class="es-mes-2">
              <h3>Esempio 2</h3>
              <p>Iniziamo inviando un messaggio vuoto all'interno della Mailbox.</p>
              <div class="es-mes-2-content">
                <ol>
                  <li>P0 arriva alla sua Receive.</li>
                  <li>Nella Mailbox c'è qualcosa, prende il messaggio ed entra nella sua sezione critica.</li>
                  <li>Nel mentre P1 arriva alla sua Receive.</li>
                  <li>Nella Mailbox non è presente nulla.</li>
                  <li>La Receive è bloccante quindi P1 attende l'arrivo di un messaggio.</li>
                  <li>P0 esce dalla sua sezione critica ed esegue una Send verso la Mailbox.</li>
                  <li>P1 esce dalla Receive, perché riceve il messaggio inviato dall'altro processo, ed entra nella sua sezione critica.</li>
                </ol>
                <img src="img/mem-cond/messaggio-2.PNG" alt="Errore">
              </div>
            </div>
          </div>
        </div>
        <div class="prob-gestione" id="5">
          <h2>I problemi della gestione dei processi</h2>
          <p>
            Quando si parla di problemi riscontrabili durante la gestione dei processi (per esempio coi semafori) bisogna cercare di evitare il più
            possibile queste 3 problematiche:
          </p>
          <ul>
            <li><FONT COLOR="red">Deadlock</FONT>: situazione in cui tutti i thread di applicazioni cooperanti sono bloccati</li>
            <li><FONT COLOR="red">Starvation</FONT>: situazione in cui l'esecuzione di uno o più thread è posticipata indefinitamente</li>
            <li><FONT COLOR="red">Livelock</FONT>: situazione in cui tutti i thread di applicazioni cooperanti riescono a svolgere qualche attività senza mai progredire</li>
          </ul>
          <div class="deadlock">
            <h3>Deadlock</h3>
            <div class="definizione-deadlock">
              <div class="def-content">
                <p id="def-deadlock-p">
                  Un insieme di processi S è in deadlock se ciascuno di essi è in attesa di accedere ad una <FONT COLOR="red">risorsa</FONT> trattenuta da un altro processo appartenente a S.
                </p>
                <div class="cond-deadlock">
                  <p>
                    È stato dimostrato (Coffman 1971) che il deadlock è caratterizzato dalla presenza contemporanea in un sistema di 4 condizioni necessarie:
                  </p>
                  <ol>
                    <li>Accesso alle risorse in mutua esclusione.</li>
                    <li>Hold and Wait: processi in possesso di risorse possono continuare a richiederne delle nuove, senza cedere quelle già acquisite anche se rimangono bloccati in attesa.</li>
                    <li>NO Preemption (nessuna prevalenza di processi).</li>
                    <li>Attesa circolare: due o più processi sono in attesa di risorse usate da un altro processo del gruppo.</li>
                  </ol>
                </div>
              </div>
              <img src="img/mem-cond/deadlock.png" alt="Errore">
            </div>
            <div class="risorse">
              <h3>Le risorse per cui i processi competono</h3>
              <p>
                I processi di un sistema <FONT COLOR="red">rischiano</FONT> la deadlock perchè <FONT COLOR="red">competono</FONT> per l'allocazione delle risorse gestite dal sistema operativo.
              </p>
              <div class="div-in-2">
                <div class="div-1">
                  <p>Sono risorse per esempio:</p>
                  <ul>
                    <li>i processori</li>
                    <li>la memoria</li>
                    <li>i semafori</li>
                    <li>le periferiche</li>
                    <li>i file</li>
                  </ul>
                </div>
                <div class="div-2">
                  <p>Le risorse si possono classificare in:</p>
                  <ul>
                    <li>Preemptable: che possono essere sottratte a un sistema senza pregiudicarne il corretto funzionamento (Esempio: processori e memoria).</li>
                    <li>Non preemptable: che non possono essere tolte a un processo senza pregiudicarne il corrett  funzionamento (Esempio: nastri e dvd).</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="RAG">
              <h2>Il RAG (Resource Allocation Graph)</h2>
              <p>La deadlock può essere scoperta prima di eseguire i processi attraverso un grafico di nome <FONT COLOR="red">RAG</FONT>.</p>
              <div class="come-rag">
                <div class="rag-text">
                  <p>Un RAG è formato da due insiemi di nodi:</p>
                  <ul>
                    <li><FONT COLOR="red">P</FONT> = {P1, P2, ..., Pn} che rappresenta i processi</li>
                    <li><FONT COLOR="red">R</FONT> = {R1, R2, ..., Rm} che rappresenta le risorse</li>
                  </ul>
                  <p>Un arco diretto da un processo ad una risorsa, Pi→Ri, denota che Pi ha richiesto Rj</p>
                  <p>Un arco diretto da una risorsa ad un processo, Ri→Pi, denota che Rj è in uso da parte di Pi</p>
                  <p style="margin-top: 50px;">In un RAG:</p>
                  <ul>
                    <li>Ogni risorsa può avere un numero di copie maggiore di uno.</li>
                    <li>Se il grafo non ha cicli, non può esserci deadlock nel sistema.</li>
                    <li>Se il grafo ha un ciclo, nel sistema può esserci un deadlock.</li>
                  </ul>
                </div>
                <img src="img/mem-cond/rag.PNG" alt="Errore">
              </div>
              <div class="prop-rag">
                <h3>Le proprietà di un RAG</h3>
                <ul>
                  <li>Se il grafo non contiene cicli non c'è una deadlock nel sistema.</li>
                  <li>
                    Se il grafo contiene cicli ci può essere una deadlock:
                    <ul>
                      <li>Se il grafo rappresenta un sistema con una sola istanza per ogni risorsa allora cè sicuramente una deadlock.</li>
                      <li>Se il grafo rappresenta un sistema con istanze multiple, allora la deadlock è possibile.</li>
                    </ul>
                  </li>
                </ul>
              </div>
              <p style="margin-top: 50px;">Vediamo adesso 3 <b>esempi</b> di casistiche probabili nei RAG:</p>
              <div class="es-rag">
                <div class="img-1">
                  <img src="img/mem-cond/rag.PNG" alt="Errore">
                  <h3>NESSUN CICLO, NESSUN DEADLOCK</h3>
                </div>
                <div class="img-2">
                  <img src="img/mem-cond/es-2.PNG" alt="Errore">
                  <h3>CICLO E DEADLOCK</h3>
                </div>
                <div class="img-3">
                  <img src="img/mem-cond/es-3.png" alt="Errore">
                  <h3>CICLO E NESSUN DEADLOCK</h3>
                </div>
              </div>
              <div class="gestione-deadlock">
                <h3>Come gestire le deadlock?</h3>
                <p>Ci sono 4 possibili scelte per la gestione delle deadlock, la scelta di una di ognuna di esse dipende esclusivamente dalla situazione in cui ci si trova:</p>
                <ol>
                  <li><FONT COLOR="red">Ignorare</FONT>: quando possibile si cerca di ignorarle, gli sforzi richiesti per una loro gestione non è sempre sostenibile.</li>
                  <li><FONT COLOR="red">Prevenire</FONT>: si prendono tutte le precauzioni affinché una delle 4 condizioni necessarie non si verifichi mai.</li>
                  <li><FONT COLOR="red">Individuare e Ricoverare</FONT>: si verifica costantemente il grafo di allocazione risorse, individuato un ciclo si “killano” uno o più processi coinvolti, che vanno riportati al loro stato iniziale (recovery) prima di essere di nuovo eseguiti.</li>
                  <li><FONT COLOR="red">Evitare</FONT>: attraverso un'allocazione oculata delle risorse.</li>
                </ol>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="fine">
        <h1>FINE</h1>
        <p style="text-align: center; margin: 50px;"><b>Grazie per essere arrivati fino a qui!</b></p>
        <p>
          Ci tengo a ringraziare il mio prof di TePI per avermi fornito le slide da cui buona parte degli argomenti affrontati deriva. <br>
          Inoltre ringrazio <a href="https://www.youtube.com/@GetTheCookie" style="color: red;" target="_blank">@GetTheCookie</a> su Youtube per avermi dato la possibilità di sviluppare un approfondimento dedicato ai Mutex. <br>
          Infine ci tengo a far sapere che tutti i gli pseudocodici utilizzati per spiegare l'accesso dei thread/processi alla memoria condivisa sono stati scritti
          completamente da me e ogni altra immagine utilizzata è stata modificata per essere ottimizzata alla visualizzazione su questo sito.
        </p>
      </div>
  </main>
  <footer>
    <p>Copyright 2023</p>
    <p>Lorenzo Fiore</p>
    <p>ISIS J.M .Keynes</p>
    <p>Gazzada Schianno</p>
  </footer>
</body>
</html>
